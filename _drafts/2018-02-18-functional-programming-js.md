---
layout: post
title:  "Разработка на ReactJS. Функциональное программирование"
date:   2018-02-18 14:22:29 +0300
category: Frontend
author: "Artamoshkin Maxim"
image: "/assets/react-functional-programming.png"
image_alt: ""
tags: [React, ReactJS, Lessons, JavaScript, JS]
description: "В настоящее время становится популярным такой подход к извлечению информации, как машинное обучение. На базе его принципов и алгоритмов создается множество аналитических решений в бизнесе и процессы формирования коммерческих баз данных."
---

Продолжая серию статей о React, поговорим о функциональной парадигме программирования, так как React и Flux основаны на функциональных методах.

Функциональное программирование одна из “горячих” тем из мира JavaScript. Но как раздел дискретной математики и парадигма программирования существует еще с давних пор.
Функциональному, как правило, противопоставляется императивный подход к программированию. <!-- more -->

Императивный подход предполагает за собой выполнение последовательных действий на протяжении программы, хранение и изменение состояния приложения. 

Функциональное программирование напротив, подразумевает результаты лишь на выполнение функций и принятием этих результатов следующими функциями, также при функциональной парадигме не возможно хранение и изменение данных, только их копии.

 Многие использовали некоторые концепции функционального программирования в императивном подходе сами того не понимая, к примеру, “анонимные функции” или “callback-функции”, которые хорошо развиты в таких языках как C#, Python и др. Также анонимные функции (они же “стрелочные функции” =>) появились в ES6 версии JavaScript, что сделало его более пригодным к функциональному подходу.

### История ###
Истоками функционального программирования является лямбда-исчисление, которое появилось в далеких 1930-х, благодаря математику Алонзо Черчу (Alonzo Church). Которое было разработано для формализации и анализа вычислимости. Это было формальной системой до тех пор, пока в 1950-х Джон Маккарти (John McCarthy), исследователь в области искусственного интеллекта, не проявил интерес к исследованиям Алонзо Черча. В 1958 году Джон Маккарти уже представил язык программирования LISP, основанный на лямбда-логике, он и стал первым функциональным языком. Хотя с первых версий и имел наклонности к императивности.  

### Концепции ###

Функциональное программирование весьма специфичен и сильно отличается от других парадигм. Но в реальных проектах приложений часто используется их смешение. К примеру, при использовании императивного подхода нередко используются описанные ниже концепции.

#### Чистые функции ####
Чистыми называются функции, которые производят вычисление на основе ее аргументов и всегда возвращают значение или другую функцию, а также не имеющие побочных эффектов.

Побочными эффектами функции являются:
- Чтение и запись глобальных переменных;
- Реагирование и обработка внешних событий;
- Зависимость результатов от внешних факторов;
- Выполнение ввода-вывода.

#### Функции высших порядков ####
Функции высших порядков - это такие функции которых один из аргументов имеется функция и/или эта функция возвращает функцию.
Ярким примером в JavaScript являются встроенные функции `map`, `filter`, `join` и т.д

#### Состояние #### 
Основной особенностью и отличием от императивного подхода является отсутствие состояния приложения. Императивный подход подразумевает операции над глобальными переменными, создание и изменение данных, функциональный же, напротив, не имеет побочных эффектов и единственный эффектом является возвращаемый результат на основе вычислений от переданных функции аргументов.

С состоянием:
```js
let magicNum = 1;

let changeMagicNumber() =>  {
	magicNum += 10;
}

changeMagicNumber();
console.log(magicNum);
```

Без состояния:
```js
let magicNum = 1;

let changeMagicNumber(val) {
	return val + 10;
}

magicNum = changeMagicNumber(magicNum);
console.log(magicNum);
``` 

В первом случае функция не является чистой, так как оперирует с глобальной переменной. Во втором случае глобальная перменная передается в виде аргумента функции, и только после ее выполнения присваивается новое значение. То есть имеем состояние только после выполнения этой функции.

*Плюсы:*
- Тестируемость 
- Ссылочная прозрачность

В React существует понятие *Stateless Functional Component*. Это компоненент который не содержит состояния (*state*) или ссылок на DOM объекты, в них передаются параметры *props* и контекст. Повторюсь, такие функции легко переиспользовать и тестировать, так как они не имеют побочных эффектов.

#### Неизменяемость ####
Неизменяемость подразумевает под собой, что во время выполнения программа не может изменять свои данные, а лишь создавать их копии. 
Другими словами неизменяемый объект (*immutable*) нельзя изменить после его создания, и наоборот изменяемый объект (*mutable*) может быть изменен после создания.

Неизменяемость занимает ключевое место в функциональном программировании. Использование изменяемых данных чаще всего приводит к ошибкам, чем неизменяемое. В JS не стоит путать с зарезервированным словом const, оно лишь создает переменную которой нельзя переназначать после создания. Данные созданные с использованием const не являются иммутабельными, так как свойства этого объекта все еще изменяемы.

С выхода ES6 работать с неизменяемыми данными стало гораздо проще. К примеру, новый объект можно создать через `Object.assign()` или через оператор расширения.

Иммутабельность дает массу плюсов:
- Код становится более прозрачным;
- Меньше неочевидных ошибок;
- Проще кешировать;
- Атомарность создания объектов.

Минусы:
- Нагрузка на CPU;
- Нагрузка на память и сборщик мусора.

#### Каррирование ####
Каррирование имеет прямое отношение к функциям высших порядков. Это способ конструирования функций, где функция от n аргументов превращается в цепочку вложенных n функций.

Пример:
```js
var property = curry(function(key, target){
    return target[key];
});
var duration = property('duration');
duration({ duration: 10, ... }); 
property('name', {name: 'Sam'});  
```

#### Композиция ####

Композиция - применение результата одной функции в качестве аргумента другой.

Например:
```js
fn1(fn2(val))
```

Так как при функциональном подходе логика программы разбивается на небольшие чистые функции, то для работы приложения необходимо их собрать в более крупные функции. Этот процесс называется композицией. При составлении композиции используется много различных подходов. Один из них, вероятно вам уже знакомый, композиция через вложение функций в аргументы другой функции

```js
unction addOne(x) {
  return x + 1;
}
function timesTwo(x) {
  return x * 2;
}
console.log(addOne(timesTwo(3))); //7
console.log(timesTwo(addOne(3))); //8
```

Но такой способ имеет существенный недостаток - он плохо масштабируем. Есть более гибкое решение, композиция через compose. У этого метода, также существует множество реализаций. Приведу пример, с реализацией через call.

```js
Function.prototype.compose = function(g) {
     var fn = this;
     return function() {
         return fn.call(this, g.apply(this, arguments));
     };
};
var f = mult2.compose(square).compose(add1);
console.log(f(5));
```

Такой подход более масштабируем и более подходит для длинных цепочек. Либо есть вариант вызова compose с полным списком функций.

```js
const compose = (...fns) =>
 (arg) =>
   fns.reduce(
     (composed, f) => f(composed),
     arg
   )
let fn = compose(fn1,fn2, fn3);
fn(1);
```

На вход compose получает значение, которое будет передано в качестве аргумента для первой функции, которая в свою очередь передает результат следующей, в конечном счете compose возвращает единственное значение, результат работы всех функций.


#### Рекурсия ####

В функциональной парадигме не существует такого понятия как цикл. Поэтому перебор данных производится посредством рекурсии.
Рекурсивные функции вызывают сами себя. 

Классическим примером является вычисление факториала. 

Сначала вычислим факториал посредством циклов:

```js
function factorial(num)
{
    if (num < 0) {
        return -1;
    }
    else if (num == 0) {
        return 1;
    }
    var tmp = num;
    while (num-- > 2) {
        tmp *= num;
    }
    return tmp;
}

var result = factorial(8);
console.log(result);

// Output: 40320
```

И то же самое, только используя рекурсивные вызовы:

```js
function factorial(num)
{
    if (num < 0) {
        return -1;
    }
    else if (num == 0) {
        return 1;
    }
    else {
        return (num * factorial(num - 1));
    }
}

var result = factorial(8);
document.write(result);

// Output: 40320
```